### Object.is vs ===

| a, b            | `Object.is(a, b)` | `a === b` |
| --------------- | :---------------: | :-------: |
| -0, +0          |       false       |   true    |
| NaN, NaN        |       true        |   false   |
| Number.NaN, NaN |       true        |   false   |
| NaN, 0/0        |       true        |   false   |
| {}, {}          |       false       |   false   |

- `Object.is`는 `===`와 달리 숫자의 부호 구분, NaN 처리 가능
- 객체 비교 시 `===`와 동일하게 참조 비교
- 침고) `0 / 0`은 `NaN`

### 함수

함수를 정의하는 방법

1. 함수 선언문
2. 함수 표현식

함수 선언문 vs 함수 표현식: 호이스팅

- 함수 선언문은 함수 자체가 호이스팅되지만 표현식은 변수만 호이스팅된다.
- 고로 function 키워드를 사용해 생성된 함수는 함수 선언 전에 함수 호출이 가능한 반면, 표현식을 통해 정의된 함수는 함수 할당 전에 함수를 호출할 수 없다
- 표현식에 의한 함수 정의가 가능한 이유는 자바스크립트에서 함수가 일급 객체이기 때문

> 일급 객체란, 다른 모든 연산에 적용할 수 있는 객체
>
> 함수를 1) 변수에 할당할 수 있고, 2) 매개변수로 전달할 수 있고 3) 반환값으로 사용될 수 있기 떄문에 함수는 일급객체이다.

일반 함수 vs 화살표 함수: this 바인딩

- 일반 함수는 호출 시점에 this가 정해지는 데에 반해
- 화살표 함수는 항상 상위 스코프의 this를 따른다
- 때문에 화살표 함수는 클래스 생성에는 부적합
- 화살표 함수는 arguments 사용 불가

함수 생성 시 주의 사항

- 부수효과 피하기
- 함수는 최대한 작게, 한가지의 기능만 하도록
- 변수명 고려
  - 한글명 변수명도 가독성의 이점. 하지만 번들링 크기에 영향을 주지 않는지 확인 필요 (이 부분은 terser로 보완가능)
  - 콜백 함수 사용시 네이밍 함수를 사용하면 디버깅에 유리

> 부수효과란?
>
> - 함수 내부 동작이 함수 외부에 영향을 주는 것
> - 부수효과가 없는 함수를 순수함수라고 한다
> - 부수효과: API 호출 (HTTP 요청) / console.log (콘솔 창에 영향) / 리액트에서 useEffect hook
