# 리액트 개발을 위한 자바스크립트

## 객체 동등 비교

- 리액트에서는 props가 하나의 객체로 전달된다
- memoization을 한 컴포넌트는 새로운 props와 이전 props 간의 얕은 비교를 통해 리렌더링을 결정한다
- 얕은 비교란 객체의 1 depth 속성, 메소드에 대해서만 비교 (props.a, props.b ...)
- 비교시 `Object.is` 사용 (`===` 아니고)

### Object.is vs ===

| a, b            | `Object.is(a, b)` | `a === b` |
| --------------- | :---------------: | :-------: |
| -0, +0          |       false       |   true    |
| NaN, NaN        |       true        |   false   |
| Number.NaN, NaN |       true        |   false   |
| NaN, 0/0        |       true        |   false   |
| {}, {}          |       false       |   false   |

- `Object.is`는 `===`와 달리 숫자의 부호 구분, NaN 처리 가능
- 객체 비교 시 `===`와 동일하게 참조 비교
- 침고) `0 / 0`은 `NaN`

## 함수

함수를 정의하는 방법

1. 함수 선언문
2. 함수 표현식

### 함수 선언문 vs 함수 표현식: 호이스팅

- 함수 선언문은 함수 자체가 호이스팅되지만 표현식은 변수만 호이스팅된다.
- 고로 function 키워드를 사용해 생성된 함수는 함수 선언 전에 함수 호출이 가능한 반면, 표현식을 통해 정의된 함수는 함수 할당 전에 함수를 호출할 수 없다
- 표현식에 의한 함수 정의가 가능한 이유는 자바스크립트에서 함수가 일급 객체이기 때문

> 일급 객체란, 다른 모든 연산에 적용할 수 있는 객체
>
> 함수를 1) 변수에 할당할 수 있고, 2) 매개변수로 전달할 수 있고 3) 반환값으로 사용될 수 있기 떄문에 함수는 일급객체이다.

### 일반 함수 vs 화살표 함수: this 바인딩, arguments 사용 가능 여부, 호이스팅

- 가장 큰 차이점은 this 바인딩
- 일반 함수는 호출 시점에 this가 정해지는 데에 반해
- 화살표 함수는 항상 상위 스코프의 this를 따른다
- 때문에 화살표 함수는 클래스 생성에는 부적합
- 화살표 함수는 `arguments` 사용 불가 -> 성능 이점

### 함수 생성 시 주의 사항

- 부수효과(사이드 이펙트) 피하기
- 함수는 최대한 작게, 한가지의 기능만 하도록
- 변수명 고려
  - 한글명 변수명도 가독성의 이점. 하지만 번들링 크기에 영향을 주지 않는지 확인 필요 (이 부분은 terser로 보완가능)
  - 콜백 함수 사용시 네이밍 함수를 사용하면 디버깅에 유리

> 부수효과란?
>
> - 함수 내부 동작이 함수 외부에 영향을 주는 것
> - 부수효과가 없는 함수를 순수함수라고 한다
> - 부수효과: API 호출 (HTTP 요청) / console.log (콘솔 창에 영향) / 리액트에서 useEffect hook

## 클래스: `프로토타입`, `this`

- 클래스란 공통된 객체 인스턴스를 만들기 위한 템플릿
- contructor를 통해 인스턴스의 속성을 지정할 수 있다.
- 클래스로 생성된 인스턴스의 메소드로 클래스의 메소드를 호출할 수 있는 이유는 프로토타입 체이닝 때문이다.
- 자바스크립트의 클래스는 내부적으로 프로토타입으로 동작하며, 이는 함수로 구현되어 있다.
- 클래스에서는 this를 통해 인스턴스에 접근이 가능하다.
- static 키워드로 정의된 정적 메소드는 인스턴스가 아닌 클래스의 메소드로 직접 호출해야한다.
- 때문에 정적메소드 내에서는 this로 인스턴스에 접근할 수 없다.

> 클래스와 프로토타입은 그럼 완전히 동일하게 동작할까? 아니다.
>
> 1. 동작 순서와 2) static이 다르게 동작한다.

## 이벤트 루프와 비동기 처리

### 자바스크립트는 싱글 스레드이다.

- 한 번에 한가지 작업만, 동기식으로 수행할 수 있다.
- 동기식이란 A 작업이 끝난 뒤에 B 작업을 하는 것을 말한다.
- 즉, 앞선 작업이 끝날 때까지 다음 작업은 실행되지 않고 기다린다.
- 자바스크립트는 본래 브라우저를 위해 개발된 언어, 1) 브라우저에서 자바스크립트로 할 일이 많지 않았으며, 2) 멀티 스레드일 경우 DOM 처리 시의 동시성 문제큰 문제를 야기할 수 있어 싱글 스레드가 더 적합 (어쩌면 멀티스레드가 더 많지 않다고 보는 편이 맞을지도)

여기서 잠깐, 프로세스와 스레드

- 프로세스란 프로그램의 작업 단위. 프로그램이 실행되기 위한 작업의 한 단위
- 프로세스가 복잡해지면, 그만큼 복잡한 여러 작업이 필요 -> 이걸 한 번에 처리하기 어려움
- 한 프로세스에서 여러 스레드로 나누어 작업하면 효율적인 작업 가능. 동시에 여러 작업이 가능하기 때문
- 한 프로세스는 여러 스레드를 가질 수 있고, 스레드끼리는 서로 자원을 공유할 수 있음
- 단, 이런 멀티 스레드는 동시성 문제가 있음. 여러 스레드가 동시에 같은 자원을 수정하려고 하면? 이런 경우 처리가 복잡

## 구조분해 할당

- 구조 분해 할당시 기본값을 지정하는 것은 undefined인 값에만 유효하다.
- null, NaN 인 값에는 기본값을 설정할 수 없다. (무시됨)

## 클로저

### 활용사례

- 부분적용함수
- 커링함수
- 리액트에서 인자가 적용된 이벤트 핸들러를 전달해줄 때

  ```tsx
  // 1
  const MemoizedComponent = () => {
    const onClick = (name) => useCallback((e) => {...}, [])
    return <button onClick={onClick('foo')} />
  }

  // 2
  const Component = () => {
    const onClick = (e) => {}
    return <button onClick={() => onClick('foo')} />
  }
  ```

  - 단순히 가독성 측면을 넘어서
  - 2번의 방법은 렌더링마다 함수가 생성되기 떄문에 메모되지 않는 반면, 1번의 방법은 메모를 할 수 있어 성능의 이점이 있다

---

# 더 알아보기

- `void 0`
- 클래스형 컴포넌트에서 내부 함수(메소드) 구현 시 this.setState 사용불가
  - this.setState가 어디에 속한건지?
  - 책 41쪽 코드 참고
  - this의 메소드로 호출을 했는데 왜 this.setState에 접근하지 못하는지 이해안감
- [[TSError] ` Option 'module' must be set to 'NodeNext'`](https://www.totaltypescript.com/concepts/option-module-must-be-set-to-nodenext-when-option-moduleresolution-is-set-to-nodenext)
- 클래스와 프로토타입이 어떻게 다르게 동작하는지
- any 타입보다 unknown 타입이 더 좋은 이유는?
- 모듈 시스템에서 호이스팅은 어떤 영향을 주는가?
- 덕타입, 구조적 타이핑이란?
