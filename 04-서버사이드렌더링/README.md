## 서버사이드 렌더링

### 서버사이드 렌더링이란,

- 서버에서 렌더링을 수행, 렌더링된 HTML파일을 클라이언트에 전달해주는 방식
- 기존의 서버사이드 렌더링은 라우팅 시(페이지 이동 시) 매번 서버에서 새로운 html 파일을 요청, 다운받아 화면을 보여주는 방식 -> 페이지 간 로드 시간이 길어짐

### 싱글 페이지 어플리케이션

- 하나의 페이지 안에서 **자바스크립트**로 모든 작업 (렌더링, 라우팅 등)을 수행하는 애플리케이션
- 자바스크립트의 역할이 커지면서 JS 파일의 크기도 커짐 -> 초기 다운로드해야할 리소스가 커짐 -> 첫 페이지 로드 시간이 길어짐
- 기술의 발전에도 불구하고 웹 페이지 로딩 속도는 여전히 느림 -> 웹에서 제공하는 js의 리소스와 성능이 개선되는데 비해 클라이언트에서 수행되는 js의 크기가 더욱 커지고 있음을 시사
- SPA 등장에서 더 중요한 점은, 웹 애플리케이션의 거의 모든 동작을 서버에서 하던 기존 방식에서 클라이언트의 역할이 분리되었다는 점이다.(클라리언트와 서버의 역할 분리) 서버에서는 정적인 자바스크립트와 마크업 파일을 전달, api로 클라이언트와 서버 간의 통신. 서로 분리됨으로써 수정과 확장에 용이해졌다.

### SSR 장단점

장점

- 완성된 html 파일을 응답하기 떄문에, 검색엔진에 유리 (검색엔진이 수집하는 정보:html 파일의 오픈 그래프와 메타 정보)
- 보안에 유리: 자바스크립트는 쉽게 수정 또는 도청에 위험
- 안정적인 성능: SSR에서 렌더링의 성능은 사용자 기기, 환경이 아닌 서버의 성능에 영향을 받기 때문에
- 첫 페이지 로드 속도(**FCP**): 모든 리소스 (특히 아주 비대해진 js. 모든 페이지를 동작하게 하는 최적화되지 않은 하나의 큰 js 파일)을 다운받은 후에 첫 렌더링을 시작하는 SPA와 다르게 첫 페이지만 서버에서 렌더링하여 응답한다면, 좀 더 빠르게 렌더링 가능

단점

- 코드가 실행되는 환경 고려: 서버에서는 브라우저 api나 window 객체는 사용할 수 없다. 코드가 실행되는 환경을 고려하여 개발해야하고, window나 브라우저 저장소를 사용해야할 때 서버 환경에서의 대응이 필요하다.
- 서비스 지연: 클라이언트에서 렌더링이 늦어지면 임시 ui(스켈레톤 같은 로딩 ui)를 렌더링할 수 있지만, 서버에서의 렌더링 지연은 응답지연으로 직결된다.
- 적절한 서버 구축: ~~그게 만만치 않다~~

결국은 CSR, SSR. 상황에 따라, 각각의 장단점을 고려한 적절한 선택

- tree shaking, code splitting 등 최적화를 거친 CSR
- 페이지 간의 성능을 개선한 SSR
  - **back and force cache**: 앞 뒤 페이지 캐시
  - **페인트 홀딩**: 라우팅 간에 렌더링이 지연되는 동안 이전 화면을 유지하는 기법
  - **shared element transitions**: 라우팅 간의 동일한 요소를 유지하여 전환이 부드럽게 보이도록 하는 기법

## Next

- Next.js는 ssr 시 hydrate 과정에서 발생하는 불필요한 연산, 네트워크 요청 등을 줄이기 위해(서버에서 이미 수행된 값을 재사용하기 위해) 서버에서 수행한 작업의 결과물을 script와 window 에 저장 (page props 뿐 아니라 스타일, fallback 정보 등 여러 정보)
- css-in-js in ssr: ssr에서 css-in-js 를 사용할 때는 첫 렌더링에 스타일이 포함되지 않아 깜빡임 문제를 해결하기 위해 별도 초기화 과정이 필요하다.
  1. 서버 렌더링 시 스타일 정보를 **미리 수집**
  2. 해당 스타일 정보를 context로 제공
  - 이를 위해 \_document 파일의 getInitialProps 정적 메소드 사용

### getInitialProps

- export default 되는 페이지 컴포넌트의 정적 메소드로 추가되어야 한다.
- 프로미스를 반환하는 비동기 함수여야 한다.
- 첫 렌더링 시점을 알 수 있다

  - 첫 렌더링 시에는 페이지 전체 요청, 이후에는 `_next`로 시작하는 경로로 json 파일만 요청

  ```tsx
  Component.getInitialProps = (context: AppContext) => {
    const {
      ctx: { req },
      router: { pathname },
    } = context

    if (
      req &&
      !req.url.startWith('/_next') &&
      !['/500', '/404', '/_error'].includes(pathname)
    ) {
      // 첫 요청 시 수행할 작업
    }

    // 꼭 기존의 initialProps는 그대로 반환해주어야한다
    const appProps = App.getInitialProps(context)
    return appProps
  }
  ```
